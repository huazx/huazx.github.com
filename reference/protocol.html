<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Chapter&nbsp;6.&nbsp;Jolokia Protocol</title><link xmlns:xslthl="http://xslthl.sf.net" href="css/base.css" rel="stylesheet" type="text/css"><link xmlns:xslthl="http://xslthl.sf.net" href="css/style.css" rel="stylesheet" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.72.0"><link rel="start" href="index.html" title="Jolokia - Reference Documentation"><link rel="up" href="index.html" title="Jolokia - Reference Documentation"><link rel="prev" href="proxy.html" title="Chapter&nbsp;5.&nbsp;Proxy Mode"><link rel="next" href="mbeans.html" title="Chapter&nbsp;7.&nbsp;Jolokia MBeans"></head><body><div class="navheader"><div>
     <div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="proxy.html" title="Chapter&nbsp;5.&nbsp;Proxy Mode">上一页</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="index.html" title="Jolokia - Reference Documentation">目录</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="mbeans.html" title="Chapter&nbsp;7.&nbsp;Jolokia MBeans">下一页</a></div></div></div><div class="chapter"><div class="titlepage"><div><div>
     <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="protocol"></a>Chapter&nbsp;6.&nbsp;Jolokia协议</h1></div></div>
     本章节将介绍Jolokia采用的JSON-over-HTTP协议。该通信是基于请求 - 响应范式，每个请求的结果保存在一个单一的响应回复中。</div><div xmlns:xslthl="http://xslthl.sf.net" class="sidebar-border"><div class="sidebar"><p class="title"><b>GET URLs are chatty</b></p>
      Keep in mind
      that many web servers log the requested path of every request, including
      parameters passed to a GET request, so sending messages over GET
      often bloats server logs.
    </div></div>
     <p>
      Jolokia请求发送方式有两种: 其中一种是HTTP GET方式, 这种方式请求参数被编码后完全放入了URL中. 另外一种是POST请求, 这种方式将一个JSON格式的数据装载到了HTTP POST的正文(body)中.
      GET请求适合与简单的用例以及通过浏览器测试agent. POST请求使用的是HTTP请求体的JSON数据,更适合复杂的请求，并提供一些额外的功能（例如使用POST批量传输请求）。</p><p>
      agent代理返回的响应内容总是使用JSON格式表示。它具有相同的格式，无论是使用GET还是POST请求。</p><p>
      本章的其余部分分为两个部分：第一部分，一般结构的请求和响应,之后，Jolokia表示法支持操作定义。</p><div class="note"><h3 class="title"></h3>
      Unfortunately the term <span class="emphasis"><em>operation</em></span> is
      used in different contexts which should be
      distinguished from one another. <span class="emphasis"><em>Jolokia operations</em></span> denote
      the various kind of Jolokia requests, whereas <span class="emphasis"><em>JMX
      operations</em></span> are methods which can be invoked on an JMX
      MBean. Wherever the context requires it, this documents uses
      <span class="emphasis"><em>Jolokia</em></span> or <span class="emphasis"><em>JMX</em></span> as
      prefix.  
    </div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="request-response"></a>6.1.&nbsp;请求和响应</h2></div></div></div><p>
        Jolokia knows about two different styles of handling
        requests, which are distinguished by the HTTP method used: GET
        or POST. Regardless of what method is used, the agent doesn't
        keep any state on the server side (except of course that
        MBeans are mostly obviously stateful). So in this aspect, the
        communication can be considered
       <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_top">REST</a>
        like<sup>[<a name="rest-comment" href="#ftn.rest-comment">7</a>]</sup>.
      </p><div class="section"><div class="titlepage"><div><div>
        <h3 class="title"><a name="get-request"></a>6.1.1.&nbsp;GET 请求</h3></div></div></div>
      <p>
          访问Jolokia最简单的方法是通过发送HTTP GET请求.这些请求的所有参数进行编码后存在于请求URL中。 通常情况下，Jolokia在使用的URL中提取参数的路径信息部分。在路径信息，每部分被一个斜杠（/）分隔。请求URL格式一般为</p><pre class="synopsis">&lt;base-url&gt;/&lt;type&gt;/&lt;arg1&gt;/&lt;arg2&gt;/..../</pre>
          <p>
          The <code class="literal">&lt;base-url&gt;</code> 指明要访问的agent. 通常为
          <code class="uri">http://localhost:8080/jolokia</code>, 但这取决于你的安装部署. 通常,  为部署的agent名称, 默认情况下是基于agent的文件名
          (例如<code class="filename">jolokia.war</code>).
          <code class="literal">&lt;type&gt;</code>  指明Jolokia支持的操作 (在下一节介绍), 接下来的几个斜杠分割的参数用来指明特定的操作.
        </p>
        <p>
          例如, the following URL executes a
          <code class="constant">read</code> Jolokia operation on the MBean
          <code class="literal">java.lang:type=Memory</code> for reading the
          attribute <code class="literal">HeapMemoryUsage</code> (see <a href="protocol.html#read">Section&nbsp;6.2.1, &#8220;Reading attributes (read)&#8221;</a>). It is assumed, that the agent is
          reachable under the base URL
          <code class="uri">http://localhost:8080/jolokia</code>: 
          </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</pre></div><p>
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="sidebar-border"><div class="sidebar"><p class="title"><b>
            Why escaping ?
          </b></p>
          You might wonder why simple URI encoding isn't enough for
          escaping slashes. The reason is that JBoss/Tomcat has a
          strange behaviour when returning an HTTP response
          <code class="literal">HTTP/1.x 400 Invalid URI: noSlash</code> for
          any URL which contains an escaped slash in the path info
          (i.e. <code class="literal">%2F</code>). The reason behind this
          behaviour is security related, slashes get decoded on the
          agent side before the agent-servlet gets the
          request. Other appservers might exhibit a similar
          behaviour, so Jolokia uses an own escaping mechanism. 
        </div></div><p>
          If one of the request parts contain a slash
          (<code class="literal">/</code>) (e.g. as part of you bean's name) it
          needs to be escaped. An exclamation mark
          (<code class="literal">!</code>) is used as escape character<sup>[<a name="no-backslash" href="#ftn.no-backslash">8</a>]</sup>. A exclamation mark needs to be doubled for
          escaping. Any other characted preceded by an exclamation mark
          is taken literally. Table <a href="protocol.html#escape-rules" title="Table&nbsp;6.1.&nbsp;Escaping rules">Table&nbsp;6.1, &#8220;转义规则&#8221;</a>
          illustrates the escape rules as used in GET requests.           
        </p><div xmlns:xslthl="http://xslthl.sf.net" class="table">
          <p class="title"><b>表格&nbsp;6.1.&nbsp;转义规则</b></p><div class="table-contents"><table id="escape-rules"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
              <td>转义序列</td>
              <td>字符</td>
            </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
            <td><code class="constant">!/</code></td>
            <td><code class="constant">/</code></td>
          </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
            <td><code class="constant">!!</code></td>
          <td><code class="constant">!</code></td>
          </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
            <td><code class="constant">!</code><span class="emphasis"><em>(anything else)</em></span></td>
            <td><span class="emphasis"><em>(anything else)</em></span></td>
          </tr></table></div></div><p>
          For example, to read the atrribute <code class="literal">State</code>
          on the MBean named
          <code class="literal">jboss.jmx:alias=jmx/rmi/RMIAdaptor</code>, an
          access URL like this has to be constructed:
        </p><div class="informalexample"><pre class="literallayout">.../read/jboss.jmx:alias=jmx!/rmi!/RMIAdaptor/State</pre></div><p>
          Client libraries like <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://search.cpan.org/~roland/jmx4perl" target="_top">JMX::Jmx4Perl</a>
          do this sort of escaping transparently. 
        </p><p>
          Escaping can be avoided alltogether if a slightly different
          variant for a request is used (which doesn't look that
          REST-stylish, though). Instead of providing the information
          as path-info, a query parameter <code class="literal">p</code> can be
          used instead. This should be URL encoded, though. For the
          example above, the alternative is
          </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia?p=/read/jboss.jmx:alias=jmx%2Frmi%2FRMIAdaptor/State</pre></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div>
          <h3 class="title"><a name="post-request"></a>6.1.2.&nbsp;POST 请求</h3></div></div></div><p>
          POST requests are the most powerful way to communicate
          with the Jolokia agent. There are fewer escaping issues and it
          allows for features which are not available with GET
          requests. POST requests uses a fixed URL and put their payload
          within the HTTP request's body. This payload is represented
          in <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.json.org" target="_top">JSON</a>, a
          data serialization format originating from JavaScript
          world.
        </p><p>
          The JSON format for a single request is a JSON object, which
          is essentially a map with keys (or
          <span class="emphasis"><em>attributes</em></span>) and values. All requests
          have a common mandatory attribute,
          <code class="constant">type</code>, which specifies the kind of JMX
          operation to perform. The other attributes are either
          operation specific as described in <a href="protocol.html#jolokia-operations">Section&nbsp;6.2, &#8220;Jolokia operations&#8221;</a> or are <span class="emphasis"><em>processing
          parameters</em></span> which influence the overall behaviour
          and can be mixed in to any request. See <a href="protocol.html#processing-parameters">Section&nbsp;6.3, &#8220;Processing parameters&#8221;</a> for details.
        </p><p>
          A sample read request in JSON format looks like the
          following example. It has a <code class="constant">type</code>
          "read"
          (case doesn't matter) and the three attributes
          <code class="constant">mbean</code>, <code class="constant">attribute</code>
          and <code class="constant">path</code> which are specific to a read
          request. 
        </p><div class="example"><a name="request-example"></a>
        <p class="title"><b>示例&nbsp;6.1.&nbsp;JSON Request</b></p><div class="example-contents"><pre class="programlisting">
  {
    "type" : "read",
    "mbean" : "java.lang:type=Memory",
    "attribute" : "HeapMemoryUsage",
    "path" : "used",
  }</pre></div></div><br class="example-break"><p>
          Each request JSON object results in a single JSON response
          object contained in the HTTP answer's body. A <span class="emphasis"><em>bulk
          request</em></span> contains multiple Jolokia requests within
          a single HTTP request. This is done by putting individual
          Jolokia requests into a JSON array:
        </p><pre class="programlisting">
 [
  {
    "type" : "read",
    "attribute" : "HeapMemoryUsage",
    "mbean" : "java.lang:type=Memory",
    "path" : "used",
  },
  { 
    "type" : "search"
    "mbean" : "*:type=Memory,*",
  }
 ]</pre><p>
          This request will result in a JSON array containing multiple
          JSON responses within the HTTP response. They are returned
          in same order as the requests in the initial bulk request.
        </p></div><div class="section"><div class="titlepage"><div><div>
          <h3 class="title"><a name="responses"></a>6.1.3.&nbsp;响应</h3></div></div></div><p>
          Responses are always encoded in UTF-8 JSON, regardless whether the
          requst was a GET or POST request.  In general, two kinds of
          responses can be classified: In the normal case, a HTTP
          Response with response code 200 is returned, containing the
          result of the operation as a JSON payload. In case of an
          error, a 4xx or 5xx code will be returned and the JSON
          payload contains details about the error
          occured (e.g. 404 means "not found"). (See
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_top">this page</a>
          for more information about HTTP error codes..)
        </p><p>
          In the non-error case a JSON response looks mostly the same
          for each request type except for the
          <code class="constant">value</code> attribute which is request type
          specific. 
        </p><p>
          The format of a single Jolokia response is
        </p><div class="example"><a name="response-example"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;JSON Response</b></p><div class="example-contents"><pre class="programlisting">
 {
   "value": .... ,
   "status" : 200,
   "timestamp" : 1244839118,
   "request": {
               "type": ...,
               ....
              },
   "history":[
               {"value": ... ,
                "timestamp" : 1244839045
               }, ....
             ]
 }</pre></div></div><br class="example-break"><p>
          For successful requests, the <code class="constant">status</code> is
          always <code class="literal">200</code> (the HTTP success code). The
          <code class="constant">timestamp</code> contains the epoch
          time<sup>[<a name="epoch-time" href="#ftn.epoch-time">9</a>]</sup> when the
          request has been handled. The request leading to this
          response can be found under the attribute
          <code class="constant">request</code>. Finally and optionally, if
          history tracking is switched on (see <a href="protocol.html#history">Section&nbsp;6.5, &#8220;Tracking historical values&#8221;</a>), an entry with key
          <code class="constant">history</code> contains a list of historical
          values along with their timestamps. History tracking is only
          available for certain type of requests
          (<code class="constant">read</code>, <code class="constant">write</code> and
          <code class="constant">exec</code>). The <code class="constant">value</code>
          is specific for the type of request, it can be a single
          scalar value or a monster JSON structure.
        </p><p>
          If an error occurs, the <code class="constant">status</code> will be
          a number different from <code class="literal">200</code>. An error
          response looks like
        </p><pre class="programlisting">
  {
    "status":400,
    "error_type":"java.lang.IllegalArgumentException",
    "error":"java.lang.IllegalArgumentException: Invalid request type 'java.lang:type=Memory'",
    "stacktrace":"java.lang.IllegalArgumentException: Invalid request type 'java.lang:type=Memory'\n
                  \tat org.cpan.jmx4perl.JmxRequest.extractType(Unknown Source)\n
                  \tat org.cpan.jmx4perl.JmxRequest.&lt;init&gt;(Unknown Source) ...."
  }</pre><p>
            For status codes it is important to distinguish status
            codes as they appear in Jolokia JSON response objects
            and the HTTP status code of the (outer) HTTP
            response. There can be many Jolokia status codes, one for
            each Jolokia request contained in the single HTTP request. The
            HTTP status code merely reflect the status of agent itself
            (i.e. whether it could perform the operation at all), whereas the
            Jolokia response status reflects the result of the
            operation (e.g. whether the performed operation throws an
            exception). So it is not uncommon to have an HTTP status
            code of 200, but the contained JSON response(s) indicate
            some errors.
        </p><p>
          I.e. the <code class="constant">status</code> has a code in the range
          <code class="literal">400 .. 499</code> or <code class="literal">500 .. 599</code>
          <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_top">as it is specified for HTTP return codes</a>.
          The <code class="constant">error</code> member contains an error
          description. This is typically the message of an exception
          occured on the agent side<sup>[<a name="mbeanexception-wrapping" href="#ftn.mbeanexception-wrapping">10</a>]</sup>. Finally, <code class="constant">error_type</code> contains the Java class name
          of the exception occured.
          The <code class="constant">stacktrace</code> contains a Java stacktrace
          occured on the server side (if any stacktrace is available).
          </p><p>
          For each type of operation, the format of the
          <code class="constant">value</code> entry is explained in
          <a href="protocol.html#jolokia-operations">Section&nbsp;6.2, &#8220;Jolokia operations&#8221;</a>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pathes"></a>6.1.4.&nbsp;Pathes</h3></div></div></div><p>
          Before we come to the Jolokia operation, the general concept
          of <span class="emphasis"><em>inner pathes</em></span> requires some
          explanation. 
        </p><p>
          An <span class="emphasis"><em>inner path</em></span> points to a certain
          substructure (plain value, array, hash) within a a complex
          JSON value. Think of it as something like "XPath lite". This
          is best explained by an example:
        </p><p>
          The attribute <code class="literal">HeapMemoryUsage</code> of the MBean 
          <code class="literal">java.lang:type=Memory</code> can be
          requested with the URL 
          <code class="literal">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</code>
          which returns a complex JSON structure like
          </p><pre class="programlisting">
 {
   "committed" : 18292736,
   "used" : 15348352,
   "max" : 532742144,
   "init" : 0
 }</pre><p>
        </p><p>
          In order to get to the value for used heap memory you should
          specify an inner path <code class="literal">used</code>, so that the
          request
          <code class="literal">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used</code>
          results in a response of <code class="literal">15348352</code>.  If
          the attribute contains arrays at some level, use a numeric
          index (0 based) as part of the inner path if you want to
          traverse into this array.
        </p><p>
          For both, GET and POST requests, pathes must be escaped as
          described in <a href="protocol.html#escape-rules" title="Table&nbsp;6.1.&nbsp;Escaping rules">Table&nbsp;6.1, &#8220;Escaping rules&#8221;</a> when they
          contain slashes (<code class="literal">/</code>) or exclamation marks
          (<code class="literal">!</code>).
        </p></div></div><div class="section"><div class="titlepage"><div><div>
          <h2 class="title"><a name="jolokia-operations"></a>6.2.&nbsp;Jolokia 操作</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="read"></a>6.2.1.&nbsp;Reading attributes (read)</h3></div></div></div><p>
    Reading MBean attributes is probably the most used JMX method,
    especially when it comes to monitoring. Concerning Jolokia, it is
    also the most powerful one with the richest semantics. Obviously
    the value of a single attribute can be fetched, but Jolokia
    supports also fetching of a list of given attributes on a single
    MBean or even on multiple MBeans matching a certain pattern.
  </p><p>
    Reading attributes are supported by both kinds of requests,
    <code class="literal">GET</code> and <code class="literal">POST</code>. 
  </p><div class="note"><h3 class="title"></h3>
    Don't confuse fetching multiple attributes on possibly multiple
    MBeans with bulk requests. A single read request will always
    result in a single read response, even when multiple attribute
    values are fetched. Only the single response's structure of the
    <code class="literal">value</code> will differ dependening on what kind of
    read request was performed.
  </div><p>
    A read request for multiple attributes on the same MBean is
    initiated by giving a list of attributes to the request. For a
    POST request this is an JSON array, for a GET request it is a
    comma separated list of attribute names (where slashes and
    exclamation marks must be escaped as described in <a href="protocol.html#escape-rules" title="Table&nbsp;6.1.&nbsp;Escaping rules">Table&nbsp;6.1, &#8220;Escaping rules&#8221;</a>). If no attribute is provided, then all
    attributes are fetched.  The MBean name can be given as a pattern
    in which case the attributes are read on all matching MBeans. If a
    MBean pattern and multiple attributes are requestes, then only the
    value of attributes which matches both are returned, the others
    are ignored. Pathes cannot be used with multi value reads, though.
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-read"></a>6.2.1.1.&nbsp;GET read request</h4></div></div></div><p>
      The GET URL for a read request has the following format:
    </p><pre class="synopsis">&lt;base-url&gt;/read/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;inner path&gt;</pre><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.2.&nbsp;GET Read Request</b></p><div class="table-contents"><table id="d0e2504"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
          <td>Part</td>
          <td>Description</td>
          <td>Example</td>
        </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="literal">&lt;mbean name&gt;</code></td>
        <td>
          The <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/6/docs/api/javax/management/ObjectName.html" target="_top">ObjectName</a>
          of the MBean for which the attribute should be fetched. It
          contains two parts: A domain part and a list of properties
          which are separated by <code class="literal">:</code>. Properties
          themselves are combined in a comma separated list of
          key-value pairs. This name can be a pattern in which case
          multiple MBeans are queried for the attribute value.
        </td>
        <td><code class="literal">java.lang:type=Memory</code></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="literal">&lt;attribute name&gt;</code></td>
        <td>Name of attribute to read. This can be a list of Attribute
        names separated by comma. Slashes and exclamations marks need
        to be escaped as described in <a href="protocol.html#escape-rules" title="Table&nbsp;6.1.&nbsp;Escaping rules">Table&nbsp;6.1, &#8220;Escaping rules&#8221;</a>. If no attribute is given, all
        attributes are read.</td>
        <td><code class="literal">HeapMemoryUsage</code></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="literal">&lt;inner path&gt;</code></td>
        <td>
          This optional part describes an <span class="emphasis"><em>inner
          path</em></span> as described in <a href="protocol.html#pathes">Section&nbsp;6.1.4, &#8220;Pathes&#8221;</a>
        </td>
        <td><code class="literal">used</code></td>
      </tr></table></div></div><p>
      With this URL the used heap memory can be obtained:
      </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia/java.lang:type=Memory/HeapMemoryUsage/used</pre></div><p>           
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="post-read"></a>6.2.1.2.&nbsp;POST read request</h4></div></div></div><p>
      A the keys available for read POST requests are shown in the
      following table.
    </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.3.&nbsp;POST Read Request</b></p><div class="table-contents"><table id="d0e2582"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
          <td>Key</td>
          <td>Description</td>
          <td>Example</td>
        </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">type</code></td>
        <td><span class="bold"><strong>read</strong></span></td>
        <td></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">mbean</code></td>
        <td>MBean's ObjectName which can be a pattern</td>
        <td><code class="literal">java.lang:type=Memory</code></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">attribute</code></td>
        <td>Attribute name to read or a JSON array containing a list
        attributes to read. No attribute is given, then all attributes
        are read.</td>
        <td><code class="literal">HeapMemoryUsage</code>, <code class="literal">[
        "HeapMemoryUsage", "NonHeapMemoryUsage" ]</code></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">path</code></td>
        <td>Inner path for accessing the value of a complex value
        (<a href="protocol.html#pathes">Section&nbsp;6.1.4, &#8220;Pathes&#8221;</a>)</td>
        <td><code class="constant">used</code></td>
      </tr></table></div></div><p>
      The following request fetches the number of active threads:      
    </p><pre class="programlisting">
{ 
   "type":"read",
   "mbean":"java.lang:type=Threading",
   "attribute":"ThreadCount"
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="response-read"></a>6.2.1.3.&nbsp;Read response</h4></div></div></div><p>
      The general format of the JSON response is described in <a href="protocol.html#responses">Section&nbsp;6.1.3, &#8220;Responses&#8221;</a> in detail.  A typical response for an
      attribute read operation for an URL like
      </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/</pre></div><p>
      looks like 
    </p><pre class="programlisting">
 {
   "value":{
             "init":134217728,
             "max":532742144,
             "committed":133365760,
             "used":19046472
           },
   "status":200,
   "timestamp":1244839118,
   "request":{
               "mbean":"java.lang:type=Memory",
               "type":"read",
               "attribute":"HeapMemoryUsage"
             },
   "history":[{"value":{
                         "init":134217728,
                         "max":532742144,
                         "committed":133365760,
                         "used":18958208
                       },
               "timestamp":1244839045
             }, ....
             ]
 }</pre><p>
      The <code class="constant">value</code> contains the response's
      value. For simple data types it is a scalar value, more complex
      types are serialized into a JSON object. See <a href="protocol.html#serialization">Section&nbsp;6.4, &#8220;Object serialization&#8221;</a> for detail on object serialization.
    </p><p>
      For read request to a single MBean with multiple attributes, the
      returned value is a JSON object with the attribute names as keys
      and their values as values. For example a request to
      <code class="literal">http://localhost:8080/jolokia/read/java.lang:type=Memory</code>
      leads to
    </p><div class="informalexample"><pre class="programlisting">
{
 "timestamp": 1317151518,
 "status": 200,
 "request": {"mbean":"java.lang:type=Memory","type":"read"},
 "value":{
   "Verbose": false,
   "ObjectPendingFinalizationCount": 0,
   "NonHeapMemoryUsage": {"max":136314880,"committed":26771456,"init":24317952,"used":15211720},
   "HeapMemoryUsage": {"max":129957888,"committed":129957888,"init":0,"used":2880008}
 }
}</pre></div><p>
      A request to a MBean pattern returns as value a JSON object,
      with the MBean names as keys and as value another JSON object
      with the attribute name as keys and the attribute values as
      values. For example a request
      <code class="literal">http://localhost:8080/jolokia/read/java.lang:type=*/HeapMemoryUsage</code> 
      returns something like
    </p><div class="informalexample"><pre class="programlisting">
{
 "timestamp": 1317151980,
 "status": 200,
 "request": {"mbean":"java.lang:type=*","attribute":"HeapMemoryUsage","type":"read"},
 "value": { 
    "java.lang:type=Memory": { 
      "HeapMemoryUsage": {"max":129957888,"committed":129957888,"init":0,"used":3080912}
    }
 }
}
</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="write"></a>6.2.2.&nbsp;Writing attributes (write)</h3></div></div></div><p>
    Writing an attribute is quite similar to reading one, except that the request takes an
    additional <code class="constant">value</code> element.
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-write"></a>6.2.2.1.&nbsp;GET write request</h4></div></div></div><p>
        Writing an attribute wit an GET request, an URL with the following format has to be used:         
        </p><pre class="synopsis">&lt;base url&gt;/write/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;value&gt;/&lt;inner path&gt;</pre><p>    
      </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.4.&nbsp;GET Write Request</b></p><div class="table-contents"><table id="d0e2709"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
            <td>Part</td>
            <td>Description</td>
            <td>Example</td>
          </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="literal">&lt;mbean name&gt;</code></td>
          <td>MBean's ObjectName</td>
          <td><code class="literal">java.lang:type=ClassLoading</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="literal">&lt;attribute name&gt;</code></td>
          <td>Name of attribute to set</td>
          <td><code class="literal">Verbose</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="literal">&lt;value&gt;</code></td>
          <td>
            The attribute name to value. The value must be serializable as described in 
            <a href="protocol.html#serialization-request">Section&nbsp;6.4.2, &#8220;Request parameter serialization&#8221;</a>.
          </td>
          <td><code class="literal">true</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="literal">&lt;path&gt;</code></td>
          <td>   
            Inner path for accessing the parent object on which to set the value.
            (See also <a href="protocol.html#pathes">Section&nbsp;6.1.4, &#8220;Pathes&#8221;</a>). Note, that this is
            <span class="emphasis"><em>not</em></span> the path to the attribute itself,
            but to the object carrying this attribute. With a given
            path it is possible to deeply set an value on a complex
            object. 
          </td>
          <td></td>
        </tr></table></div></div><p>
        For example, you can set the garbage collector to verbose mode by using
        something like
        </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia/write/java.lang:type=Memory/Verbose/true</pre></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="post-write"></a>6.2.2.2.&nbsp;POST write request</h4></div></div></div><p>
        The keys which are evaluated for a POST write request are:
      </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.5.&nbsp;POST Write Request</b></p><div class="table-contents"><table id="d0e2792"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
            <td>Key</td>
            <td>Description</td>
            <td>Example</td>
          </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">type</code></td>
          <td><span class="bold"><strong>write</strong></span></td>
          <td></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">mbean</code></td>
          <td>MBean's ObjectName</td>
          <td><code class="literal">java.lang:type=ClassLoading</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">attribute</code></td>
          <td>Name of attribute to set</td>
          <td><code class="literal">Verbose</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">value</code></td>
          <td>
            The attribute name to value. The value must be serializable as described in 
            <a href="protocol.html#serialization-request">Section&nbsp;6.4.2, &#8220;Request parameter serialization&#8221;</a>.
          </td>
          <td><code class="literal">true</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">path</code></td>
          <td>   
            An optional inner path for specifying an inner object on which to set the
            value. See <a href="protocol.html#pathes">Section&nbsp;6.1.4, &#8220;Pathes&#8221;</a> for more on inner pathes.
          </td>
          <td></td>
        </tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="response-write"></a>6.2.2.3.&nbsp;Write response</h4></div></div></div><p>
        As response for a write operation the old attribute's value is
        returned. For a request
        </p><pre class="synopsis">http://localhost:8080/jolokia/write/java.lang:type=ClassLoading/Verbose/true</pre><p>
        you get the answer (supposed that verbose mode was switched
        off for class loading at the time this request was sent)
      </p><pre class="programlisting">
 { 
   "value":"false",
   "status":200,
   "request": {
                "mbean":"java.lang:type=ClassLoading",
                "type":"write",
                "attribute":"Verbose",
                "value":true
              }
 }</pre><p>
        The response is quite similar to the read operation except for
        the additional <code class="constant">value</code> element in the request
        (and of course, the different <code class="constant">type</code>).
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="exec"></a>6.2.3.&nbsp;Executing JMX operations (exec)</h3></div></div></div><p>
    Beside attribute provides a way for the execution of exposed JMX
    operations with optional arguments. The same as for writing
    attributes, Jolokia must be able to serialize the arguments. See
    <a href="protocol.html#serialization">Section&nbsp;6.4, &#8220;Object serialization&#8221;</a> for details. Execution of
    overloaded methods is supported. The JMX specifications recommends
    to avoid overloaded methods when exposing them via JMX, though.
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-exec"></a>6.2.3.1.&nbsp;GET exec request</h4></div></div></div><p>
      The format of an GET exec request is
      </p><pre class="synopsis">&lt;base url&gt;/exec/&lt;mbean name&gt;/&lt;operation name&gt;/&lt;arg1&gt;/&lt;arg2&gt;/....</pre><p>
    </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.6.&nbsp;GET Exec Request</b></p><div class="table-contents"><table id="d0e2906"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
          <td>Part</td>
          <td>Description</td>
          <td>Example</td>
        </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="literal">&lt;mbean name&gt;</code></td>
        <td>MBean's ObjectName</td>
        <td><code class="literal">java.lang:type=Threading</code></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="literal">&lt;operation name&gt;</code></td>
        <td>  
          Name of the operation to execute. If an overloaded method,
          it is mandatory to provide a method signature as
          well. A signature consist the fully qualified argument class
          names or native types, separated by columns and enclosed with
          parentheses.  
        </td>
        <td>
          <code class="literal">loadUsers(java.lang.String,int)</code>
        </td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="literal">&lt;arg1&gt;</code>, <code class="literal">&lt;arg2&gt;</code>, ...</td>
        <td>
          String representation for the arguments required to execute this
          operation. Only certain data types can be used here as
          desribed in <a href="protocol.html#serialization-request">Section&nbsp;6.4.2, &#8220;Request parameter serialization&#8221;</a>.
        </td>
        <td><code class="literal">"true","true"</code></td>
      </tr></table></div></div><p>
      The following request will trigger a garbage collection:
      </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia/exec/java.lang:type=Memory/gc</pre></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="post-exec"></a>6.2.3.2.&nbsp;POST exec request</h4></div></div></div><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.7.&nbsp;POST Exec Request</b></p><div class="table-contents"><table id="d0e2977"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
            <td>Key</td>
            <td>Description</td>
            <td>Example</td>
          </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">type</code></td>
          <td><span class="bold"><strong>exec</strong></span></td>
          <td></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">mbean</code></td>
          <td>MBean's ObjectName</td>
          <td><code class="literal">java.lang:type=Threading</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">operation</code></td>
          <td>The operation to execute, optionally with a signature as
          described above.
          </td>
          <td><code class="literal">dumpAllThreads</code></td>
        </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
          <td><code class="constant">arguments</code></td>
          <td>
            An array of arguments for invoking this operation. The value must be serializable as described in 
            <a href="protocol.html#serialization-request">Section&nbsp;6.4.2, &#8220;Request parameter serialization&#8221;</a>.
          </td>
          <td><code class="literal">[true,true]</code></td>
        </tr></table></div></div><p>
      The following request dumps all threads (along with locked
      monitors and locked synchronizers, thats what the boolean
      arguments are for):
    </p><pre class="programlisting">
{
   "type":"EXEC",
   "mbean":"java.lang:type=Threading",
   "operation":"dumpAllThreads",
   "arguments":[true,true]
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="response-exec"></a>6.2.3.3.&nbsp;Exec response</h4></div></div></div><p>
      For an <code class="constant">exec</code> operation, the response
      contains the return value of the
      operation. <code class="constant">null</code> is returned if either the
      operation returns a null value or the operation is declared as
      void. A typical response for an URL like
      </p><pre class="synopsis">http://localhost:8080/jolokia/exec/java.util.logging:type=Logging/setLoggerLevel/global/INFO</pre><p>
      looks like
    </p><pre class="programlisting">
 {
   "value":null,
   "status":200,
   "request": {
                "type":"exec",
                "mbean":"java.util.logging:type=Logging",
                "operation":"setLoggerLevel",
                "arguments":["global","INFO"]
              }
}

</pre><p>
      The return value get serialized as described in <a href="protocol.html#serialization">Section&nbsp;6.4, &#8220;Object serialization&#8221;</a>.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="search"></a>6.2.4.&nbsp;Searching MBeans (search)</h3></div></div></div><p>
    With the Jolokia search operation the agent can be queried for
    MBeans with a given pattern.  Searching will be performed on every
    <code class="classname">MBeanServer</code> found by the agent.
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-search"></a>6.2.4.1.&nbsp;GET search request</h4></div></div></div><p>
      The format of the search GET URL is:
    </p><pre class="synopsis">&lt;base-url&gt;/search/&lt;pattern&gt;</pre><p>
      This mode is used to query for certain MBean. It takes a single
      argument <code class="literal">pattern</code> for
      specifying the search parameter like in 
      </p><pre class="synopsis">http://localhost:8080/jolokia/search/*:j2eeType=J2EEServer,*</pre><p>
    </p><p>
      You can use patterns as described <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/j2se/1.5.0/docs/api/javax/management/ObjectName.html" target="_top">here</a>,
      i.e. it may contain wildcards like <code class="literal">*</code> and
      <code class="literal">?</code>. The Mbean names matching the query
      are returned as a list within the response.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="post-search"></a>6.2.4.2.&nbsp;POST search request</h4></div></div></div><p>
      A search POST request knows the following keys:
    </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.8.&nbsp;POST Search Request</b></p><div class="table-contents"><table id="d0e3108"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
          <td>Key</td>
          <td>Description</td>
          <td>Example</td>
          </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">type</code></td>
        <td><span class="bold"><strong>search</strong></span></td>
        <td></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">mbean</code></td>
        <td>The MBean pattern to search for</td>
        <td><code class="literal">java.lang:*</code></td>
      </tr></table></div></div><p>
      The following request searches for all MBeans registered in the
      domain <code class="literal">java.lang</code>
    </p><pre class="programlisting">
{ 
   "type":"SEARCH",
   "mbean":"java.lang:*"
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="response-search"></a>6.2.4.3.&nbsp;Search response</h4></div></div></div><p>
      The answer is a list of MBean names which matches the pattern or an empty 
      list if there was no match.
    </p><p>
      For example, the request
      </p><div class="informalexample"><pre class="literallayout">http://localhost:8888/jolokia/search/*:j2eeType=J2EEServer,*</pre></div><p>
      results in
      </p><pre class="programlisting">
 {
   "value": [
              "jboss.management.local:j2eeType=J2EEServer,name=Local"
            ],
   "status":200,
   "timestamp":1245305648,
   "request": {
       "mbean":"*:j2eeType=J2EEServer,*","type":"search"
   }
 }</pre><p>
    </p><p>
      The returned MBean names are properly <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/management/ObjectName.html" target="_top">quoted</a>
      so that they can be directly used as 
      input for other requests.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="list"></a>6.2.5.&nbsp;Listing MBeans (list)</h3></div></div></div><p>
      The list operation collects information about accessible
      MBeans. This information includes the MBean names, their
      attributes, operations and noticifactions along with type
      information and description (as far as they are provided by the
      MBean author which doesn't seem to be often the case).
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-list"></a>6.2.5.1.&nbsp;GET list request</h4></div></div></div><p>
      The GET request format for a Jolokia list request is
    </p><pre class="synopsis">&lt;base-url&gt;/list/&lt;inner path&gt;</pre><p>
      The <code class="literal">&lt;inner path&gt;</code>, as described in <a href="protocol.html#pathes">Section&nbsp;6.1.4, &#8220;Pathes&#8221;</a> 
      specifies a subset of the complete response. You can
      use this to select a specific domain, MBean or
      attribute/operation. See the next section for the format of the
      complete response.      
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="post-list"></a>6.2.5.2.&nbsp;POST list request</h4></div></div></div><p>
      A list POST request has the following keys:
    </p><div xmlns:xslthl="http://xslthl.sf.net" class="table"><p class="title"><b>Table&nbsp;6.9.&nbsp;POST list Request</b></p><div class="table-contents"><table id="d0e3198"><thead xmlns:xi="http://www.w3.org/2001/XInclude"><tr>
          <td>Key</td>
          <td>Description</td>
          <td>Example</td>
        </tr></thead><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">type</code></td>
        <td><span class="bold"><strong>list</strong></span></td>
        <td></td>
      </tr><tr xmlns:xi="http://www.w3.org/2001/XInclude">
        <td><code class="constant">path</code></td>
        <td>
          Inner path for accessing the value of a subset of the complete list
          (<a href="protocol.html#pathes">Section&nbsp;6.1.4, &#8220;Pathes&#8221;</a>). 
        </td>
        <td><code class="literal">java.lang/type=Memory/attr</code></td>
      </tr></table></div></div><p>
      The following request fetches the information about the MBean <code class="literal">java.lang:type=Memory</code>
    </p><pre class="programlisting">
{ 
   "type":"LIST",
   "path":"java.lang/type=Memory"
}</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="response-list"></a>6.2.5.3.&nbsp;List response</h4></div></div></div><p>
      The <code class="constant">value</code> has the following format:
    </p><pre class="programlisting">
 { 
  &lt;domain&gt; : 
  {
    &lt;prop list&gt; : 
    {
      "attr" : 
      {
        &lt;attr name&gt; : 
        { 
          "type" : &lt;attribute type&gt;,
          "desc" : &lt;textual description of attribute&gt;,
          "rw"   : true/false
        },
        ....
      }, 
      "op" :
      {
         &lt;operation name&gt; :
         {
           "args" : [
                      { 
                       "type" : &lt;argument type&gt;
                       "name" : &lt;argument name&gt;
                       "desc" : &lt;textual description of argument&gt;
                      },
                      .....
                     ],
           "ret"  : &lt;return type&gt;,
           "desc" : &lt;textual description of operation&gt;
         }, 
         .....
      },
      "not" : 
      {
         "name" : &lt;name&gt;,
         "desc" : &lt;desc&gt;,
         "types" : [ &lt;type1&gt;, &lt;type2&gt; ]
      }
    }, 
    ....
  },
  ....
 }</pre><p>
      The <code class="literal">domain name</code> and the <code class="literal">property
      list</code> together uniquely identify a single MBean. The
      property list is in the so called <span class="emphasis"><em>canonical
      order</em></span>, i.e. in the form
      <code class="literal">"&lt;key1&gt;=&lt;val1&gt;,&lt;key2&gt;=&lt;val2&gt;,.."</code>
      where the keys are ordered alphabetically. Each MBean has zero
      or more attributes and operations which can be reached in an
      MBeans JSON object with the keys <code class="constant">attr</code> and
      <code class="constant">op</code> respectively. Within these groups the
      contained information is explained above in the schema and
      consist of Java types for attributes, arguments and return
      values, descriptive information and whether an attribute is
      writable (<code class="constant">rw</code> == <code class="constant">true</code>) or
      read-only.
    </p><p>
      As for reading attributes you can fetch a subset of this information using an
      path. E.g a path of <code class="literal">domain/prop-list</code> would return the value for a single
      bean only. For example, a request 
      </p><div class="informalexample"><pre class="literallayout">http://localhost:8080/jolokia/list/java.lang/type=Memory</pre></div><p>
      results in an answer
    </p><pre class="programlisting">
 {
   "value":
   { 
     "op":
     { 
       "gc":
       {
         "args":[],
         "ret":"void",
         "desc":"gc"
       }
     },
     "attr":
     {
       "NonHeapMemoryUsage":
       {
         "type":"javax.management.openmbean.CompositeData",
         "rw":false,
         "desc":"NonHeapMemoryUsage"
       },
       "Verbose":
       {
         "type":"boolean",
         "rw":true,
         "desc":"Verbose"
       },
       "HeapMemoryUsage":
       {
         "type":"javax.management.openmbean.CompositeData",
         "rw":false,
         "desc":"HeapMemoryUsage"
       },
       "ObjectPendingFinalizationCount":
       {
         "type":"int",
         "rw":false,
         "desc":"ObjectPendingFinalizationCount"
       }
     }
   },
   "status":200,
   "request":
   {
     "type":"list",
     "path":"java.lang\/type=Memory"
   }
 }</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3294"></a>6.2.5.4.&nbsp;Restrict depth of depth</h4></div></div></div><p>
      The optional parameter <code class="literal">maxDepth</code> can be used
      to restrict the depth of the return tree. Two value are
      possible: A <code class="literal">maxDepth</code> of 1 restricts the
      return value to a map with the JMX domains as keys, a
      <code class="literal">maxDepth</code> of 2 truncates the map returned to
      the domain names (first level) and the MBean's properties
      (second level). The final values of the maps don't have any
      meaning ander are dummy values.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="version"></a>6.2.6.&nbsp;Getting the agent version (version)</h3></div></div></div><p>
    The Jolokia command <code class="constant">version</code> returns the version of
    the Jolokia agent along with the protocol version. 
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="get-version"></a>6.2.6.1.&nbsp;GET version request</h4></div></div></div><p>
      The GET URL for a version request has the following format:
    </p><pre class="synopsis">&lt;base-url&gt;/version</pre><p>
      For GET request the <code class="literal">version</code> part can be
      omitted since this is the default command if no command is
      provided as path info.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="post-version"></a>6.2.6.2.&nbsp;POST version request</h4></div></div></div><p>
      A version POST request has only a single key
      <code class="constant">type</code> which has to be set to 
      <span class="bold"><strong>version</strong></span>.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="response-version"></a>6.2.6.3.&nbsp;Version response</h4></div></div></div><p>
      The response value for a version request looks like:
    </p><pre class="programlisting">
 {
    "timestamp":1287143106,
    "status":200,
    "request":{"type":"version"},
    "value":{
              "protocol":"4.0",
              "agent":"0.80",
              "info": {
                 product: "glassfish",
                 vendor": "Sun",
                 extraInfo: {
                    amxBooted: false
                 }
             }
 }</pre></div><p>
    <code class="literal">protocol</code> in the response value contains the
    protocol version used, <code class="literal">agent</code> ist the version of
    the Jolokia agent. See <a href="protocol.html#versions">Section&nbsp;6.7, &#8220;Jolokia protocol versions&#8221;</a> for the various
    protocol versions and the interoperatibility. If the agent is able
    to detect the server, additional meta information about this
    server is returned (i.e. the product name, the vendor and
    optionally some extra information added by the server detector).
  </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="processing-parameters"></a>6.3.&nbsp;Processing parameters</h2></div></div></div><p>
        Jolokia operations can be influenced by so-called
        <span class="emphasis"><em>processing parameters</em></span>. These parameters
        are provided differently for POST and GET requests.
      </p><p>
        For GET request, the processing parameter are given as normal
        query parameters:
        </p><pre class="synopsis">&lt;GET request URL&gt;?param1=value1&amp;param2=value2&amp;...</pre><p>
        For example the request
        </p><pre class="synopsis">http://localhost:8080/jolokia/list?maxObjects=100</pre><p>
        will limit the response to at max 100 values.
      </p><p>
        POST request take the processing instructions within the
        JSON request below the key <code class="constant">config</code>:
      </p><pre class="programlisting">
  {
    "type" : "list"
    "config" : { 
                 "maxObjects" : 100
               } 
  }</pre><p>
        The list of known processing parameters is:
      </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">maxDepth</code></span></dt><dd><p>
              Maximum depth of the tree traversal into a bean's
              properties. The maximum value as configured in the
              agent's configuration is a hard limit
              and cannot be exceeded by a query parameter.
            </p></dd><dt><span class="term"><code class="literal">maxCollectionSize</code></span></dt><dd><p>
              For collections (lists, maps) this is the maximum
              size. 
            </p></dd><dt><span class="term"><code class="literal">maxObjects</code></span></dt><dd><p>
              Number of objects to visit in total. A hard limit
              can be configured in the agent's configuration. 
            </p></dd><dt><span class="term"><code class="literal">ignoreErrors</code></span></dt><dd><p>
              If set to "true", a Jolokia operation will not return an
              error if an JMX operation fails, but includes the
              exception message as value. This is useful for e.g. the
              read operation when requesting multiple attributes'
              values. Default: false 
            </p></dd><dt><span class="term"><code class="literal">mimeType</code></span></dt><dd><p>
              The MIME type to return for the response. By default,
              this is <code class="literal">text/plain</code>, but it can be
              useful for some tools to change it to
              <code class="literal">application/json</code>. Init parameters can
              be used to change the default mime type.
            </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="serialization"></a>6.4.&nbsp;Object serialization</h2></div></div></div><p>
        Jolokia has some object serialization facilities in order to
        convert complex Java data types to JSON and vice
        versa. Serialization works in both ways in requests and
        responses, but the capabilities differ.
      </p><p>
        Complex data types returned from the agent can be serialized
        completely into a JSON value object. It can detect cycles in
        the object graph and provides a way to limit the depth of
        serialization. For certain types (like
        <code class="classname">File</code> or
        <code class="classname">ObjectName</code>) it uses simplifier to not
        expose internal and redundant information. 
      </p><p>
        Object values used for values in 
        <span class="emphasis"><em>write</em></span> operations and arguments in
        <span class="emphasis"><em>exec</em></span>, type support is limited to a
        handful of data types.
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="serialization-response"></a>6.4.1.&nbsp;Response value serialization</h3></div></div></div><p>
          Jolokia can serialize any object into a JSON representation
          when generating the response. It uses some specific
          converters for certain well known data type with a generic
          bean converter as fallback.
        </p><p>
          The following types are directly supported:
          </p><div class="itemizedlist"><ul><li>
              Arrays and <code class="classname">java.util.List</code>
              are converted to JSON arrays
            </li><li><code class="classname">java.util.Map</code> gets
              converted into a JSON object. Note, however, that JSON
              Object keys are <span class="emphasis"><em>always strings</em></span>.
            </li><li><code class="classname">javax.management.openmbean.CompositeData</code>
              is converted in a JSON object, with the keys taken from
              the <code class="classname">CompositeData</code>'s key set and
              the value are its values.
            </li><li><code class="classname">javax.management.openmbean.TabularData</code>
              is serialized into one or multiple nested JSON objects
              where the keys are derived from its
              <code class="methodname">TabularType.indexName()</code>. If
              there is a single valued index, the index's value is the
              key and a <code class="classname">TabularData</code>'s row
              (which in turn is a
              <code class="classname">CompositeData</code>) is a map. With
              multi valued keys, the map is nested (first level: first
              index's value, second level: second index's value and so
              on). For the serialization of <code class="classname">TabularData</code> resulting
              from a <code class="classname"><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/6/docs/api/javax/management/MXBean.html" target="_top">MXBean</a></code> translation for
              maps, see <a href="protocol.html#serialization-mxbean">Section&nbsp;6.4.3, &#8220;Jolokia and MXBeans&#8221;</a></li><li><code class="classname">java.lang.Class</code> gets converted to
              a JSON object with keys <code class="literal">name</code> (the class
              name) and <code class="literal">interfaces</code> (the implemented
              interfaces, if any)
            </li><li><code class="classname">java.io.File</code> becomes a JSON
              object with keys <code class="literal">name</code> (file name),
              <code class="literal">modified</code> (date of last modification),
              <code class="literal">length</code> (file size in bytes),
              <code class="literal">directory</code> (whether the file is a directory),
              <code class="literal">canonicalPath</code> (the canonical path)
              and <code class="literal">exists</code>.
            </li><li><code class="classname">javax.management.ObjectName</code> is
              converted into a JSON object with the single key
              <code class="literal">objectName</code>. 
            </li><li><code class="classname">java.net.URL</code> becomes a JSON
              object with the key <code class="literal">url</code> containing
              the URL as String.
            </li><li><code class="classname">java.util.Date</code> is represented in
              an ISO-8601 format. When used with a path
              <code class="literal">time</code> the milliseconds since 1.1.1970
              00:00 UTC are returned.
            </li><li><code class="classname">org.w3c.dom.Element</code> is translated
              into a JSON object with the properties
              <code class="literal">name</code>, <code class="literal">value</code> and
              <code class="literal">hasChildNodes</code>.
            </li></ul></div><p>
        </p><p>
          Primitive and simple types (like String) are
          directly converted into their string presentation. All
          objects not covered by the list above are serialized in JSON
          objects, where the keys are the public bean properties of
          the object and the values are serialized (recursively) as
          described.
        </p><p>
          Serialization can be influenced by certain processing
          parameters given with the request (see <a href="protocol.html#processing-parameters">Section&nbsp;6.3, &#8220;Processing parameters&#8221;</a>). I.e. the recursive
          process of JSON serialization can be stopped when the data
          set gets too large. Self and other circular references
          are detected, too. If this happen, special values indicate
          the truncation of the generated JSON object.
        </p><div class="variablelist"><dl><dt><span class="term"><code class="constant">[this]</code></span></dt><dd><p>
                This label is used when a property contains a self reference 
              </p></dd><dt><span class="term"><code class="constant">[Depth limit .... ]</code></span></dt><dd><p>
                When a depth limit is used or the hard depth limit
                is exceeded, this label contains a string
                representation of the next object one level deeper.
                (see <a href="protocol.html#processing-parameters">Section&nbsp;6.3, &#8220;Processing parameters&#8221;</a>,
                parameter <code class="literal">maxDepth</code>)
              </p></dd><dt><span class="term"><code class="constant">[Reference .... ]</code></span></dt><dd><p>
                If during the traversal an object is visited a second time, this label is
                used in order to break the cycle. 
              </p></dd><dt><span class="term"><code class="constant">[Object limit exceeded]</code></span></dt><dd><p>
                The total limit of object has been exceeded and hence
                the object are not deserialized further.  (see <a href="protocol.html#processing-parameters">Section&nbsp;6.3, &#8220;Processing parameters&#8221;</a>, parameters
                <code class="literal">maxCollectionSize</code> and
                <code class="literal">maxObjects</code>)
              </p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="serialization-request"></a>6.4.2.&nbsp;Request parameter serialization</h3></div></div></div><p>
          Serialization in the upstream direction (i.e. when sending
          values for <code class="constant">write</code> operations or arguments
          for <code class="constant">exec</code> operations) differs from
          from the object serializaton as used as response values
          which is described in <a href="protocol.html#serialization-response">Section&nbsp;6.4.1, &#8220;Response value serialization&#8221;</a>. Not all types are
          supported for upstream serialization <sup>[<a name="upstream-serialization-comment" href="#ftn.upstream-serialization-comment">11</a>]</sup>
          and the capabilities differ also for POST and GET requests.
          <code class="literal">GET</code> upstream serialization is limited to
          basic types and simple arrays. POST requests on the other
          support a much large set of types, including the
          serialization of <code class="constant">Map</code>s, 
          <code class="constant">List</code>s and all <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/6/docs/api/javax/management/openmbean/OpenType.html" target="_top">Open
          Types</a>. 
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3636"></a>6.4.2.1.&nbsp;GET request values</h4></div></div></div><p>
            Since parameters get encoded in the URL for GET request,
            only the following types can used for values and arguments
            in <code class="constant">write</code> and
            <code class="constant">exec</code> requests:
            </p><div class="itemizedlist"><ul><li>String</li><li>Integer / int</li><li>Long / long</li><li>Byte / byte</li><li>Short / short</li><li>Float / float</li><li>Double / double</li><li>char</li><li>Boolean / boolean</li><li>Date</li></ul></div><p>
          </p><p>
            The serialized value is simply the string representation
            of those types. Dates can be set either by an long value
            (epoch milliseconds) or with a string value (ISO-8601
            format). Arrays of the given types are serialized as a
            comma separated list.
          </p><div class="note"><h3 class="title"></h3>
            The array support is somewhat limited since it makes a
            native split on commas. It does not yet take into account
            any quoting or escaping. For a much safer way to transport
            arrays to the agent, please consider using POST requests.
          </div><p>
            Certain <span class="emphasis"><em>tag values</em></span> are used to mark special
            values.  A <code class="constant">null</code> value has to be
            serialized as <code class="literal">[null]</code>, an empty String
            as <code class="literal">""</code>. Tag values are not required for
            POST requests.
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3687"></a>6.4.2.2.&nbsp;POST request values</h4></div></div></div><p>
            POST request take advantage of the JSON type of the value
            transfered. These are basic types for numbers
            (<code class="literal">42</code> or <code class="literal">23.5</code>),
            booleans (<code class="literal">true</code> or
            <code class="literal">false</code>) and strings
            (<code class="literal">"habanero"</code>). Also, JSON knows about
            <code class="constant">null</code> values so no special 'tags' like
            for GET requests are not required. Since JSON supports
            intrinsically key-value maps and array types, these can be
            used directly, too. I.e. if the JMX operation to execute
            takes a <code class="constant">Map</code> argument, the argument
            can be given as a JSON object. Be aware, however, that JSON
            maps (objects) only support strings as keys.
          </p><p>
            The agent knows how to convert an JSON array to Java
            Arrays (of a basic type) or Lists, depending on the
            requirement as dictated by the MBeans operation or
            attribute signature. Numbers in JSON are always transfered
            as long or double values and are as well tried to fit 
            to the MBean's signature. In case of an overflow
            (e.g. when trying to treat a long with a too large value
            as int), an exception is raised.
          </p><p>
            Upstream serialization also supports <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/6/docs/api/javax/management/openmbean/OpenType.html" target="_top">OpenType</a>s.
            If the signature of JMX exec operation or the value type
            of a JMX attribute is a <code class="classname">OpenType</code>,
            they are serialized as follows:            
          </p><div class="itemizedlist"><ul><li><code class="classname">SimpleType</code>s are extracted from
              their corresponding JSON type. 
            </li><li><code class="classname">ArrayType</code> is extracted from a
              <code class="classname">JSONArray</code> where the elements are
              serialized recursively with this algorithms. Only
              <code class="classname">ArrayType</code>s with element type
              <code class="classname">CompositeType</code> or
              <code class="classname">SimpleType</code> are supported. 
            </li><li><code class="classname">CompositeType</code> is extracted
              recursively from a <code class="classname">JSONObject</code>
              where there the string keys must fit to the
              <code class="classname">CompositeType</code>'s item names and
              the values must be serializable as open types.
            </li><li><p>
                <code class="classname">TabularType</code> is converted from
                <code class="classname">JSONObject</code>. If it is single index
                (i.e. has only one single index name), the
                <code class="classname">JSONObject</code> must have the index
                values as string keys and the map values are other
                <code class="classname">JSONObject</code>s representing the row
                data. For <code class="classname">TabularType</code>s with more
                than one index name, the incoming
                <code class="classname">JSONObjecct</code> must be a nested
                object with each index as an additional
                layer. E.g. the following JSON object works for 
                a <code class="classname">TabularType</code> with the two
                index names <code class="literal">lastname</code> and
                <code class="literal">firstname</code>:
              </p><pre class="programlisting">{ 
  "Mann": {
           "Thomas": {
                      lastname: "Mann",
                      firstname: "Thomas",
                      birth: 1875
                     },
           "Heinrich": {
                        lastname: "Mann",
                        firstname: "Heinrich",
                        birth: 1871
                       }
          }
}</pre><p>
                <code class="classname">TabularType</code> used by the MXBean
                framework for serialization of Maps are translated
                directly from maps. More details are explained in the
                next section <a href="protocol.html#serialization-mxbean">Section&nbsp;6.4.3, &#8220;Jolokia and MXBeans&#8221;</a>.
              </p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div>
                <h3 class="title"><a name="serialization-mxbean"></a>6.4.3.&nbsp;Jolokia 与 MXBeans</h3></div></div></div><p>
          The <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/6/docs/api/javax/management/MXBean.html" target="_top">MXBean Framework</a> is availale in
          the JRE since version 6 and allows for easy creation and
          registration of own MBeans. MXBeans are some what the
          successor for standard MBeans and support an annotation driven
          as well as a naming convention driven programming model. The
          most important difference to standard MBeans it the
          restriction of MXBean to reference only open types.
        </p><p>
          Although to the outside only open types are exposed by the
          MXBean framework, MXBean themselves can use more complex
          data types. The framework will translate forth and back
          between the custom and open types according to certain rules
          as declared in the MXBean <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://download.oracle.com/javase/6/docs/api/javax/management/MXBean.html" target="_top">specification</a>. 
          Most of the translations to open types fits naturally to
          Jolokia's serialization, except for the translation of Map.
        </p><p>
          When an MXBean references a map, the MXBean framework
          translates this map into a
          <code class="classname">TabularData</code> with a fixed internal
          structure, i.e. with an index <code class="literal">key</code> and
          rows with keys <code class="literal">key</code> and
          <code class="literal">value</code>. This leads directly to a JSON
          representation which is quite artificial. E.g a map with 
          two keys <code class="literal">kind</code> and
          <code class="literal">hotness</code> will be converted by the MXBean
          framework to a TabularData object which in turn would be
          translated by Jolokia to the following JSON struture
        </p><pre class="programlisting">{
  "kind" : { 
             "key": "kind",
             "value": "Habanero"
           }, 
  "hotness" : {
                "key": "hotness",
                "value": 10
              }
}</pre><p>
        Since this representation of a simple map is unnecessarily
        complicated, Jolokia treats <code class="classname">TabularData</code>
        of this kind (i.e. one index <code class="literal">key</code> and rows
        with properties <code class="literal">key</code> and
        <code class="literal">value</code>) specially in order to translate it
        back (and forth) to
      </p><pre class="programlisting">{
  "kind" : "Habanero", 
  "hotness" : 10
}</pre></div></div><div class="section"><div class="titlepage"><div><div>
  <h2 class="title"><a name="history"></a>6.5.&nbsp;跟踪历史值</h2></div></div></div><p>
        The Jolokia agents are able to keep requested values in memory
        along with a timestamp. If history tracking is switched on,
        then the agent will put the list of historical values specific
        for this request into the response. History tracking is
        toggled by an MBean operation on a Jolokia-owned MBean (see
        <a href="mbeans.html">Chapter&nbsp;7, <i xmlns:xlink="http://www.w3.org/1999/xlink">Jolokia MBeans</i></a>). This has to be done individually for each
        attribute or JMX operation to be tracked.
      </p><p>
        A <code class="constant">history</code> entry is contained in every
        response for which history tracking was switched on. A certain
        JMX operation on an Jolokia specific MBean has to be executed
        to turn history tracking on for a specific attribute or
        operation. See <a href="mbeans.html">Chapter&nbsp;7, <i xmlns:xlink="http://www.w3.org/1999/xlink">Jolokia MBeans</i></a> for details.The
        <code class="constant">history</code> property of the JSON response
        contains an array of json objects which have two attributes:
        <code class="constant">value</code> containing the historical value
        (which can be as complex as any other value) and
        <code class="constant">timestamp</code> indicating the time when this
        value was current (as measured by the server). <a href="protocol.html#response-example" title="Example&nbsp;6.2.&nbsp;JSON Response">Example&nbsp;6.2, &#8220;JSON Response&#8221;</a> has an example of a response
        containing historical values. 
      </p><p>
        For multi attribute read requests, the history entry in the
        response is a JSON object instead of an array, where this
        object's attributes are the request's attribute names and the
        values are the history arrays as described above.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="protocol-proxy"></a>6.6.&nbsp;Proxy requests</h2></div></div></div><p>
        For proxy requests, POST must be used as HTTP method so that
        the given JSON request can contain an extra section for the
        target which should be finally reached via this proxy
        request. A typical proxy request looks like
      </p><pre class="programlisting">
  {
    "type" : "read",
    "mbean" : "java.lang:type=Memory",
    "attribute" : "HeapMemoryUsage",
    "target" : { 
         "url" : "service:jmx:rmi:///jndi/rmi://targethost:9999/jmxrmi",
         "user" : "jolokia",
         "password" : "s!cr!t"
    } 
  }</pre><p>
        <code class="literal">url</code> within the <code class="literal">target</code>
        section is a JSR-160 service URL for the target server
        reachable from within the proxy agent. <code class="literal">user</code>
        and <code class="literal">password</code> are optional credentials used
        for the JSR-160 communication.
      </p></div><div class="section"><div class="titlepage"><div><div>
        <h2 class="title"><a name="versions"></a>6.7.&nbsp;Jolokia 协议版本</h2></div></div></div><p>
        The protocol definition is versioned. It contains of a major
        and minor version. Changes in the minor version are backward
        compatible to other protocol with the same major
        version. Major version changes incorporate possibly backwards
        incompatible changes. This document describes the Jolokia
        protocol version <span class="bold"><strong>6.1</strong></span>
      </p><div class="variablelist"><dl><dt><span class="term"><span class="bold"><strong>6.1</strong></span> (since 1.0.2)</span></dt><dd><p>
              Error responses contain now the original request as
              well, for single and bulk requests.
            </p></dd><dt><span class="term"><span class="bold"><strong>6.0</strong></span> (since 1.0.0)</span></dt><dd><p>
              Escaping has been changed from <code class="literal">/-/</code> to
              <code class="literal">!/</code>. This affects GET Urls and
              <span class="emphasis"><em> inner paths</em></span>.
            </p></dd><dt><span class="term"><span class="bold"><strong>5.0</strong></span> (since 0.95)</span></dt><dd><p>
              <code class="classname">javax.management.openmbean.TabularData</code>
              is serialized differently when generating the
              response. In fact, the serialization as an array in
              the former versions of this protocol is not correct,
              since <code class="classname">TabularData</code> in fact is a
              hash and not a list. It is now generated as map (or
              multiple maps), dependening on the declared
              <span class="emphasis"><em>index</em></span>. Also, access via path is now
              an access via key, not a list index. For the special
              case of MXBean map serialization, where the returned
              <code class="classname">TabularData</code> has a fixed format
              (i.e. with <code class="literal">key</code> and
              <code class="literal">value</code> columns), the
              <code class="classname">TabularData</code> is transformed to an
              appropriate map.. 
            </p><p>
              Removed JSON property <code class="literal">modified</code> from
              the serialized JSON representation of a File return
              value since it duplicated the
              <code class="literal">lastModified</code> property on the same
              object. 
            </p></dd><dt><span class="term"><span class="bold"><strong>4.3</strong></span> (since 0.91)</span></dt><dd><p>
              The <code class="literal">list</code> operation supports a
              <code class="literal">maxDepth</code> option for truncating the
              answer. 
            </p></dd><dt><span class="term"><span class="bold"><strong>4.2</strong></span> (since 0.90)</span></dt><dd><p>
              Response values are returned in the native JSON
              datatype, not always as strings as in previous versions
              of this protocol. Parameter serialization for writing
              attribute values or for arguments in exec operations has
              been enhanced for POST requests, which are now
              represented as native JSON types and not in a string
              representation as before. GET requests still use a
              simplified string representation.
            </p></dd><dt><span class="term"><span class="bold"><strong>4.0</strong></span> (17.10.2010)</span></dt><dd><p>This is the initial version for Jolokia. Versions below 4 are
            implemented by jmx4perl</p></dd></dl></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.rest-comment" href="#rest-comment">7</a>] </sup>This document will avoid the term REST as much as
          possible in order to avoid provoking any dogmatic
          resentments.</p></div><div class="footnote"><p><sup>[<a name="ftn.no-backslash" href="#no-backslash">8</a>] </sup>
            A backslash (<code class="literal">\</code>) can not be used, since
            most servlet container translate a backslash into a forward
            slash on the fly when given in an URL. 
          </p></div><div class="footnote"><p><sup>[<a name="ftn.epoch-time" href="#epoch-time">9</a>] </sup>
            Seconds since 1.1.1970
          </p></div><div class="footnote"><p><sup>[<a name="ftn.mbeanexception-wrapping" href="#mbeanexception-wrapping">10</a>] </sup>
            If the server exception
            is a subtype of <code class="classname">MBeanException</code>, the wrapped
            exception's message is used.
          </p></div><div class="footnote"><p><sup>[<a name="ftn.upstream-serialization-comment" href="#upstream-serialization-comment">11</a>] </sup>
              Conversion from a typed system to an untyped
              representation is obviously much easier than vice
              versa. Please note, that Jolokia does not replace a full
              blown JSON object serialization framework like
              Jackson. Nor does it use one in order to keep the agent small
              and simple with a low dependency count.
            </p></div></div></div><div class="navfooter"><div>
              <div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="proxy.html" title="Chapter&nbsp;5.&nbsp;Proxy Mode">上一页</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="index.html" title="Jolokia - Reference Documentation">目录</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="mbeans.html" title="Chapter&nbsp;7.&nbsp;Jolokia MBeans">下一页</a></div></div></div></body></html>